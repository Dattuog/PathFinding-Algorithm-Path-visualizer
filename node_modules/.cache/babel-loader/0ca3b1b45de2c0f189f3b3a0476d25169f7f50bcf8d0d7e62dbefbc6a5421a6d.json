{"ast":null,"code":"// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nimport { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}","map":{"version":3,"names":["getAllNodes","sortNodesByDistance","getUnvisitedNeighbours","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","length","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbors","neighbor","previousNode"],"sources":["C:/Users/Deekshith/Desktop/pathfinder/PathFinding-Algorithm-Path-visualizer/src/algorithms/dijkstra.js"],"sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nimport { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall)\r\n      continue;\r\n    \r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity)\r\n      return visitedNodesInOrder;\r\n    \r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode)\r\n      return visitedNodesInOrder;\r\n    \r\n    updateUnvisitedNeighbours(closestNode, grid);\r\n  }\r\n}\r\n\r\n// updates the neighbours,\r\n// in correspondance to the algorithm \r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,mBAAmB,EAAEC,sBAAsB,QAAQ,SAAS;AAElF,OAAO,SAASC,QAAQA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACpD,MAAMC,mBAAmB,GAAG,EAAE;EAC9BF,SAAS,CAACG,QAAQ,GAAG,CAAC;EACtB,MAAMC,cAAc,GAAGT,WAAW,CAACI,IAAI,CAAC;EACxC,OAAO,CAAC,CAACK,cAAc,CAACC,MAAM,EAAE;IAC9BT,mBAAmB,CAACQ,cAAc,CAAC;IACnC,MAAME,WAAW,GAAGF,cAAc,CAACG,KAAK,CAAC,CAAC;IAC1C;IACA,IAAID,WAAW,CAACE,MAAM,EACpB;;IAEF;IACA;IACA,IAAIF,WAAW,CAACH,QAAQ,KAAKM,QAAQ,EACnC,OAAOP,mBAAmB;IAE5BI,WAAW,CAACI,SAAS,GAAG,IAAI;IAC5BR,mBAAmB,CAACS,IAAI,CAACL,WAAW,CAAC;IACrC,IAAIA,WAAW,KAAKL,UAAU,EAC5B,OAAOC,mBAAmB;IAE5BU,yBAAyB,CAACN,WAAW,EAAEP,IAAI,CAAC;EAC9C;AACF;;AAEA;AACA;AACA,SAASa,yBAAyBA,CAACC,IAAI,EAAEd,IAAI,EAAE;EAC7C,MAAMe,kBAAkB,GAAGjB,sBAAsB,CAACgB,IAAI,EAAEd,IAAI,CAAC;EAC7D,KAAK,MAAMgB,QAAQ,IAAID,kBAAkB,EAAE;IACzCC,QAAQ,CAACZ,QAAQ,GAAGU,IAAI,CAACV,QAAQ,GAAG,CAAC;IACrCY,QAAQ,CAACC,YAAY,GAAGH,IAAI;EAC9B;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}