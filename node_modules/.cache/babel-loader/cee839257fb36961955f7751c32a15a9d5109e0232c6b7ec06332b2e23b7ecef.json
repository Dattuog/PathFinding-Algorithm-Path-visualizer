{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  // if start or finish node skip it\n  if (!startNode || !finishNode) return;\n  // arrays with values of grid dimensions\n  let vertical = Array(grid[0].length).fill().map((_, i) => i);\n  let horizontal = Array(grid.length).fill().map((_, i) => i);\n  // initializing the walls global variable to an empty array\n  walls = [];\n  // main func\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\n// main func \nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) return;\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  // recursive part where the approach to \n  // start horizontal or vertical is dependent on dir variable\n  if (dir === 0) {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  } else {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\n\n// generates a random number which is odd\nfunction generateOddRandomNumber(arr) {\n  let max = arr.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) randomNum -= 1;else randomNum += 1;\n  }\n  return arr[randomNum];\n}\n\n// func to push the coordinates of nodes into wall array\nfunction addWalls(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    let rand = generateRandomNumber(tempWalls.length);\n    tempWalls = [...tempWalls.slice(0, rand), ...tempWalls.slice(rand + 1)];\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\n// func to generate a random number for the generation of walls in tempWalls\n// within the range of tempWalls arr length\nfunction generateRandomNumber(maxValue) {\n  let randomNum = Math.floor(Math.random() * (maxValue / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === maxValue) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","Array","length","fill","map","_","i","horizontal","getRecursiveWalls","dir","num","generateOddRandomNumber","addWalls","slice","indexOf","arr","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","push","rand","generateRandomNumber","wall","maxValue"],"sources":["C:/Users/Deekshith/Desktop/pathfinder/PathFinding-Algorithm-Path-visualizer/src/maze-algorithms/recursiveDivision.js"],"sourcesContent":["let walls;\r\n\r\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n  // if start or finish node skip it\r\n  if (!startNode || !finishNode)\r\n    return;\r\n  // arrays with values of grid dimensions\r\n  let vertical = Array(grid[0].length).fill().map((_, i) => i);\r\n  let horizontal = Array(grid.length).fill().map((_, i) => i);\r\n  // initializing the walls global variable to an empty array\r\n  walls = [];\r\n  // main func\r\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\n// main func \r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\r\n  if (vertical.length < 2 || horizontal.length < 2)\r\n    return;\r\n  let dir;\r\n  let num;\r\n  if (vertical.length > horizontal.length) {\r\n    dir = 0;\r\n    num = generateOddRandomNumber(vertical);\r\n  }\r\n  if (vertical.length <= horizontal.length) {\r\n    dir = 1;\r\n    num = generateOddRandomNumber(horizontal);\r\n  }\r\n\r\n  // recursive part where the approach to \r\n  // start horizontal or vertical is dependent on dir variable\r\n  if (dir === 0) {\r\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\r\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\r\n  }\r\n  else {\r\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\r\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\r\n  }\r\n}\r\n\r\n// generates a random number which is odd\r\nfunction generateOddRandomNumber(arr) {\r\n  let max = arr.length - 1;\r\n  let randomNum = Math.floor(Math.random() * (max / 2)); \r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max)\r\n      randomNum -= 1;\r\n    else\r\n      randomNum += 1;\r\n  }\r\n  return arr[randomNum];\r\n} \r\n\r\n// func to push the coordinates of nodes into wall array\r\nfunction addWalls(dir, num, vertical, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2)\r\n      return;\r\n    for (let temp of horizontal) {\r\n      if ((temp === startNode.row && num === startNode.col) ||(temp === finishNode.row && num === finishNode.col)) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  }\r\n  else {\r\n    if (vertical.length === 2)\r\n      return;\r\n    for (let temp of vertical) {\r\n      if ((num === startNode.row && temp === startNode.col) ||(num === finishNode.row && temp === finishNode.col)) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    let rand = generateRandomNumber(tempWalls.length);\r\n    tempWalls= [...tempWalls.slice(0, rand), ...tempWalls.slice(rand + 1)];\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\n// func to generate a random number for the generation of walls in tempWalls\r\n// within the range of tempWalls arr length\r\nfunction generateRandomNumber(maxValue) {\r\n  let randomNum = Math.floor(Math.random() * (maxValue / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === maxValue) {\r\n      randomNum -= 1;\r\n    }\r\n    else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}