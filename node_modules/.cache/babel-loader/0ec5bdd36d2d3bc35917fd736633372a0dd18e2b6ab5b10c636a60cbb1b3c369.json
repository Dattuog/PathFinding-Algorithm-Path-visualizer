{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Deekshith\\\\Desktop\\\\pathfinder\\\\PathFinding-Algorithm-Path-visualizer\\\\src\\\\components\\\\PathVisualizer\\\\PathVisualizer.js\";\nimport React, { Component } from 'react';\nimport \"./PathVisualizer.scss\";\nimport Node from \"../Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\nimport Footer from \"../Footer/Footer\";\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\nimport Legend from '../Legend/Legend';\n\n// constants - initial coordinates for start and finish nodes \nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst START_NODE_ROW = 0;\nconst START_NODE_COL = 0;\nconst FINISH_NODE_ROW = 0;\nconst FINISH_NODE_COL = 1;\nclass PathVisualizer extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isPathNotFound: false,\n      visitedNodes: 0,\n      shortestNodes: 0,\n      tooltipOpen: false,\n      isVisualizing: false,\n      mainIsPressed: \"\",\n      startNode_Pos: [START_NODE_ROW, START_NODE_COL],\n      finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL]\n    };\n    // tool tip toggle\n    this.toggle = () => {\n      this.setState({\n        tooltipOpen: !this.state.tooltipOpen\n      });\n    };\n    /*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\n    // dijkstra\n    this.visualizeDijkstra = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n        start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n        finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n      try {\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        if (nodesInShortestPathOrder.length === 1) throw \"not possible\";\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n      //this.setState({ isVisualizing: false });\n    };\n    // dfs\n    this.visualizeDFS = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n        start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n        finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n      try {\n        const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        console.log(error);\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n    // bfs\n    this.visualizeBFS = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n        start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n        finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n      try {\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n    // astar\n    this.visualizeAstar = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n        start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n        finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n      try {\n        const visitedNodesInOrder = astar(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        if (nodesInShortestPathOrder.length === 1) {\n          throw \"not possible\";\n        }\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n    /*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\n    this.clearGrid = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n        start_Y = startNode_Pos[1];\n      const finish_X = finishNode_Pos[0],\n        finish_Y = finishNode_Pos[1];\n      for (let row = 0; row < this.state.grid.length; row++) {\n        for (let col = 0; col < this.state.grid[0].length; col++) {\n          if (!(row === start_X && col === start_Y || row === finish_X && col === finish_Y)) {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getInitialGrid(startNode_Pos, finishNode_Pos);\n      this.setState({\n        grid: newGrid,\n        visitedNodes: 0,\n        shortestNodes: 0\n      });\n    };\n    this.clearPath = () => {\n      if (this.state.isVisualizing) return;\n      for (let row = 0; row < this.state.grid.length; row++) {\n        for (let col = 0; col < this.state.grid[0].length; col++) {\n          if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\" || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n      const newGrid = getGridWithoutPath(this.state.grid);\n      this.setState({\n        grid: newGrid,\n        visitedNodes: 0,\n        shortestNodes: 0\n      });\n    };\n    /*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\n    this.generateRecursiveDivisionMaze = () => {\n      if (this.state.isVisualizing) return;\n      this.setState({\n        isVisualizing: true\n      });\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n      const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateWalls(walls, grid);\n    };\n    this.generateRandomMaze = () => {\n      if (this.state.isVisualizing) return;\n      this.setState({\n        isVisualizing: true\n      });\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n      const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n      const walls = randomMaze(grid, startNode, finishNode);\n      this.animateWalls(walls, grid);\n    };\n    this.animateWalls = (walls, grid) => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            const newGrid = getNewGridWithMaze(this.state.grid, walls);\n            this.setState({\n              grid: newGrid,\n              isVisualizing: false\n            });\n          }, 10 * i);\n          return;\n        }\n        setTimeout(() => {\n          const wall = walls[i];\n          const node = grid[wall[0]][wall[1]];\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\n        }, 10 * i);\n      }\n    };\n    /*------------------------------------------------------------------------------------------------------------------------------*/\n    // sets the state to visualizing, to prevent any other func from executing during the visualization\n    this.setVisualization = () => {\n      this.setState({\n        isVisualizing: !this.state.isVisualizing\n      });\n    };\n    // same as the previous func, but this one to set the state outside of this component, in algorithms visualizing components\n    this.handleClick = () => {\n      setVisualizationState(this);\n    };\n  }\n  // creates the grid when the component is mounted\n  componentDidMount() {\n    const {\n      startNode_Pos,\n      finishNode_Pos\n    } = this.state;\n    let grid = getInitialGrid(startNode_Pos, finishNode_Pos);\n    this.setState({\n      grid\n    });\n  }\n  /*-------------------------------------------------------------mouse events--------------------------------------------------------------- */ // handling mouse events to set up walls\n  handleMouseDown(row, col) {\n    const {\n      grid,\n      mainIsPressed\n    } = this.state;\n    const node = grid[row][col];\n    if (node.isStart === true && node.isFinish === false) {\n      this.setState({\n        mainIsPressed: \"start\"\n      });\n      node.isStart = false;\n    }\n    if (node.isFinish === true && node.isStart === false) {\n      this.setState({\n        mainIsPressed: \"finish\"\n      });\n      node.isFinish = false;\n    }\n    if (mainIsPressed === \"\") {\n      const newGrid = gridWithWallToggled(grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      mouseIsPressed,\n      mainIsPressed\n    } = this.state;\n    if (mainIsPressed === \"start\") {\n      const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n      this.setState({\n        grid: newGrid\n      });\n    }\n    if (mainIsPressed === \"finish\") {\n      const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n      this.setState({\n        grid: newGrid\n      });\n    }\n    if (mouseIsPressed && mainIsPressed === \"\") {\n      const newGrid = gridWithWallToggled(grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n  handleMouseUp(row, col) {\n    const {\n      mainIsPressed,\n      grid\n    } = this.state;\n    if (mainIsPressed === \"start\") {\n      this.setState({\n        mainIsPressed: \"\"\n      });\n      const startNode_Pos = [row, col];\n      const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n      this.setState({\n        mainIsPressed: \"\",\n        startNode_Pos,\n        grid: newGrid\n      });\n    }\n    if (mainIsPressed === \"finish\") {\n      const finishNode_Pos = [row, col];\n      const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n      this.setState({\n        mainIsPressed: \"\",\n        finishNode_Pos,\n        grid: newGrid\n      });\n    }\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n  handleMouseLeave(row, col) {\n    const {\n      grid,\n      mainIsPressed\n    } = this.state;\n    if (mainIsPressed === \"\") return;\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (mainIsPressed === \"start\") {\n      const newNode = {\n        ...node,\n        isStart: false,\n        isWall: false\n      };\n      newGrid[row][col] = newNode;\n    }\n    if (mainIsPressed === \"finish\") {\n      const newNode = {\n        ...node,\n        isFinish: false,\n        isWall: false\n      };\n      newGrid[row][col] = newNode;\n    }\n    this.setState({\n      grid: newGrid\n    });\n  }\n  render() {\n    const {\n      grid,\n      mouseIsPressed,\n      visitedNodes,\n      shortestNodes\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(TooltipExampleMulti, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 17\n      }, this), this.state.isPathNotFound ? /*#__PURE__*/_jsxDEV(ErrorModal, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 46\n      }, this) : null, /*#__PURE__*/_jsxDEV(AppNavbar, {\n        handleDijkstra: this.visualizeDijkstra,\n        handleDFS: this.visualizeDFS,\n        handleBFS: this.visualizeBFS,\n        handleAstar: this.visualizeAstar,\n        handleClearPath: this.clearPath,\n        handleClearGrid: this.clearGrid,\n        handleMaze: this.generateRecursiveDivisionMaze,\n        handleRandomMaze: this.generateRandomMaze,\n        handleVisualization: this.setVisualization,\n        visitedNodes: visitedNodes,\n        shortestNodes: shortestNodes\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 324,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Legend, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid\",\n        children: grid.map((row, rowIdx) => {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: row.map((node, nodeIdx) => {\n              const {\n                row,\n                col,\n                isStart,\n                isFinish,\n                isWall\n              } = node;\n              return /*#__PURE__*/_jsxDEV(Node, {\n                row: row,\n                col: col,\n                isStart: isStart,\n                isFinish: isFinish,\n                isWall: isWall,\n                mouseIsPressed: mouseIsPressed,\n                onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n                onMouseUp: (row, col) => this.handleMouseUp(row, col),\n                onMouseLeave: (row, col) => this.handleMouseLeave(row, col)\n              }, nodeIdx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 348,\n                columnNumber: 41\n              }, this);\n            })\n          }, rowIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 344,\n            columnNumber: 29\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 341,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 367,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n  }\n}\nexport default PathVisualizer;\n\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\n\nvar r = 30;\nvar c = 49;\n// creating the initial grid, calls the createNode() function\n// to initialise the node with initial properties\nconst getInitialGrid = (startNode_Pos, finishNode_Pos) => {\n  let grid = [];\n  // const startNode_Pos = [10, 15];\n  // const finishNode_Pos = [10, 35];\n  for (let row = 0; row < r; row++) {\n    const currRow = [];\n    for (let col = 0; col < c; col++) {\n      //  previously I had it as 20*50\n      currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\n    }\n    grid.push(currRow);\n  }\n  return grid;\n};\n\n// initialising the node with its initial properties\nconst createNode = (row, col, startNode, finishNode) => {\n  let start_x = startNode[0];\n  let start_y = startNode[1];\n  let finish_x = finishNode[0];\n  let finish_y = finishNode[1];\n  return {\n    row,\n    col,\n    isStart: row === start_x && col === start_y,\n    isFinish: row === finish_x && col === finish_y,\n    isWall: false,\n    distance: Infinity,\n    isVisited: false,\n    previousNode: null,\n    distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\n  };\n};\n\n// updating the grid, when the walls are tiggered\nconst gridWithWallToggled = (grid, row, col) => {\n  let newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\nconst gridDynamicNodes = (grid, row, col, pos) => {\n  console.log(`start node is currently at: row: ${row} col: ${col}`);\n  let newGrid = grid.slice();\n  const node = newGrid[row][col];\n  if (pos === \"start\") {\n    const newNode = {\n      ...node,\n      isStart: true\n    };\n    newGrid[row][col] = newNode;\n  }\n  if (pos === \"finish\") {\n    const newNode = {\n      ...node,\n      isFinish: true\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n\n// updating the grid, resetting the features except for the walls\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = {\n        ...node,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n  return newGrid;\n};\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};","map":{"version":3,"names":["React","Component","Node","dijkstra","getNodesInShortestPathOrder","dfs","bfs","astar","animatePath","animateWalls","setVisualizationState","recursiveDivisionMaze","randomMaze","AppNavbar","ErrorModal","Footer","TooltipExampleMulti","Legend","jsxDEV","_jsxDEV","Fragment","_Fragment","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathVisualizer","constructor","args","state","grid","mouseIsPressed","isPathNotFound","visitedNodes","shortestNodes","tooltipOpen","isVisualizing","mainIsPressed","startNode_Pos","finishNode_Pos","toggle","setState","visualizeDijkstra","start_X","start_Y","startNode","finish_X","finish_Y","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","length","error","setTimeout","visualizeDFS","console","log","visualizeBFS","visualizeAstar","clearGrid","row","col","document","getElementById","className","newGrid","getInitialGrid","clearPath","getGridWithoutPath","generateRecursiveDivisionMaze","walls","generateRandomMaze","i","getNewGridWithMaze","wall","node","setVisualization","handleClick","componentDidMount","handleMouseDown","isStart","isFinish","gridWithWallToggled","handleMouseEnter","gridDynamicNodes","handleMouseUp","handleMouseLeave","slice","newNode","isWall","render","children","fileName","_jsxFileName","lineNumber","columnNumber","handleDijkstra","handleDFS","handleBFS","handleAstar","handleClearPath","handleClearGrid","handleMaze","handleRandomMaze","handleVisualization","map","rowIdx","nodeIdx","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","r","c","currRow","push","createNode","start_x","start_y","finish_x","finish_y","distance","Infinity","isVisited","previousNode","distanceToFinishNode","Math","abs","pos"],"sources":["C:/Users/Deekshith/Desktop/pathfinder/PathFinding-Algorithm-Path-visualizer/src/components/PathVisualizer/PathVisualizer.js"],"sourcesContent":["import React, { Component } from 'react';\r\nimport \"./PathVisualizer.scss\";\r\nimport Node from \"../Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\r\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\r\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\r\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\r\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\r\nimport Footer from \"../Footer/Footer\";\r\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\r\nimport Legend from '../Legend/Legend';\r\n\r\n// constants - initial coordinates for start and finish nodes \r\nconst START_NODE_ROW = 0;\r\nconst START_NODE_COL = 0;\r\nconst FINISH_NODE_ROW = 0;\r\nconst FINISH_NODE_COL = 1;\r\n\r\nclass PathVisualizer extends Component {\r\n    state = {\r\n        grid: [],\r\n        mouseIsPressed: false,\r\n        isPathNotFound: false,\r\n        visitedNodes: 0,\r\n        shortestNodes: 0,\r\n        tooltipOpen: false,\r\n        isVisualizing: false,\r\n        mainIsPressed: \"\",\r\n        startNode_Pos: [START_NODE_ROW, START_NODE_COL],\r\n        finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n    }\r\n\r\n    // creates the grid when the component is mounted\r\n    componentDidMount() {\r\n        const { startNode_Pos, finishNode_Pos } = this.state;\r\n        let grid = getInitialGrid(startNode_Pos, finishNode_Pos);\r\n        this.setState({ grid });\r\n    }\r\n\r\n    // tool tip toggle\r\n    toggle = () => {\r\n        this.setState({ tooltipOpen: !this.state.tooltipOpen });\r\n    }\r\n\r\n    /*-------------------------------------------------------------mouse events--------------------------------------------------------------- */\r\n    // handling mouse events to set up walls\r\n\r\n    handleMouseDown(row, col) {\r\n        const { grid, mainIsPressed } = this.state;\r\n        const node = grid[row][col];\r\n        if (node.isStart === true && node.isFinish === false) {\r\n            this.setState({ mainIsPressed: \"start\" });\r\n            node.isStart = false;\r\n        }\r\n        if (node.isFinish === true && node.isStart === false) {\r\n            this.setState({ mainIsPressed: \"finish\" });\r\n            node.isFinish = false;\r\n        }\r\n        if (mainIsPressed === \"\") {\r\n            const newGrid = gridWithWallToggled(grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        }\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        const { grid, mouseIsPressed, mainIsPressed } = this.state;\r\n        if (mainIsPressed === \"start\") {\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\r\n            this.setState({ grid: newGrid });\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\r\n            this.setState({ grid: newGrid });\r\n        }\r\n        if (mouseIsPressed && mainIsPressed === \"\") {\r\n            const newGrid = gridWithWallToggled(grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        const { mainIsPressed, grid } = this.state;\r\n        if (mainIsPressed === \"start\") {\r\n            this.setState({ mainIsPressed: \"\" });\r\n            const startNode_Pos = [row, col];\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\r\n            this.setState({ mainIsPressed: \"\", startNode_Pos, grid: newGrid });\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const finishNode_Pos = [row, col];\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\r\n            this.setState({ mainIsPressed: \"\", finishNode_Pos, grid: newGrid });\r\n        }\r\n        this.setState({ mouseIsPressed: false });\r\n    }\r\n\r\n    handleMouseLeave(row, col) {\r\n        const { grid, mainIsPressed } = this.state;\r\n        if (mainIsPressed === \"\")\r\n            return;\r\n        let newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        if (mainIsPressed === \"start\") {\r\n            const newNode = {\r\n                ...node,\r\n                isStart: false,\r\n                isWall: false\r\n            }\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const newNode = {\r\n                ...node,\r\n                isFinish: false,\r\n                isWall: false\r\n            }\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    /*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\r\n    // dijkstra\r\n    visualizeDijkstra = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            if (nodesInShortestPathOrder.length === 1)\r\n                throw \"not possible\";\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true, isVisualizing: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false, isVisualizing: false });\r\n            }, 3000);\r\n        }\r\n        //this.setState({ isVisualizing: false });\r\n    }\r\n\r\n    // dfs\r\n    visualizeDFS = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            console.log(error)\r\n            this.setState({ isPathNotFound: true, isVisualizing: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false, isVisualizing: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // bfs\r\n    visualizeBFS = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true, isVisualizing: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false, isVisualizing: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // astar\r\n    visualizeAstar = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            if (nodesInShortestPathOrder.length === 1) {\r\n                throw \"not possible\";\r\n            }\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true, isVisualizing: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false, isVisualizing: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    /*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\r\n    clearGrid = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if (!((row === start_X && col === start_Y) || (row === finish_X && col === finish_Y))) {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        const newGrid = getInitialGrid(startNode_Pos, finishNode_Pos);\r\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\r\n    }\r\n\r\n    clearPath = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if ((document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        const newGrid = getGridWithoutPath(this.state.grid);\r\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\r\n    }\r\n\r\n    /*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\r\n    generateRecursiveDivisionMaze = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        this.setState({ isVisualizing: true });\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\r\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\r\n        const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n        this.animateWalls(walls, grid);\r\n    }\r\n\r\n    generateRandomMaze = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        this.setState({ isVisualizing: true });\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\r\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\r\n        const walls = randomMaze(grid, startNode, finishNode);\r\n        this.animateWalls(walls, grid);\r\n    }\r\n\r\n    animateWalls = (walls, grid) => {\r\n        for (let i = 0; i <= walls.length; i++) {\r\n            if (i === walls.length) {\r\n                setTimeout(() => {\r\n                    const newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n                    this.setState({ grid: newGrid, isVisualizing: false });\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const wall = walls[i];\r\n                const node = grid[wall[0]][wall[1]];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    /*------------------------------------------------------------------------------------------------------------------------------*/\r\n\r\n    // sets the state to visualizing, to prevent any other func from executing during the visualization\r\n    setVisualization = () => {\r\n        this.setState({\r\n            isVisualizing: !this.state.isVisualizing\r\n        });\r\n    }\r\n\r\n    // same as the previous func, but this one to set the state outside of this component, in algorithms visualizing components\r\n    handleClick = () => {\r\n        setVisualizationState(this);\r\n    }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed, visitedNodes, shortestNodes } = this.state;\r\n\r\n        return (\r\n            <>\r\n                \r\n                <TooltipExampleMulti />\r\n                {this.state.isPathNotFound ? <ErrorModal /> : null}\r\n                <AppNavbar\r\n\r\n                    handleDijkstra={this.visualizeDijkstra}\r\n                    handleDFS={this.visualizeDFS}\r\n                    handleBFS={this.visualizeBFS}\r\n                    handleAstar={this.visualizeAstar}\r\n                    handleClearPath={this.clearPath}\r\n                    handleClearGrid={this.clearGrid}\r\n                    handleMaze={this.generateRecursiveDivisionMaze}\r\n                    handleRandomMaze={this.generateRandomMaze}\r\n                    handleVisualization={this.setVisualization}\r\n                    visitedNodes={visitedNodes}\r\n                    shortestNodes={shortestNodes}\r\n                />\r\n\r\n                <Legend />\r\n\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isStart, isFinish, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                                            onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                        />\r\n                                    )\r\n                                })}\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n                <Footer />\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PathVisualizer;\r\n\r\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\r\n\r\n\r\n\r\nvar r = 30;\r\nvar c = 49;\r\n// creating the initial grid, calls the createNode() function\r\n// to initialise the node with initial properties\r\nconst getInitialGrid = (startNode_Pos, finishNode_Pos) => {\r\n    let grid = [];\r\n    // const startNode_Pos = [10, 15];\r\n    // const finishNode_Pos = [10, 35];\r\n    for (let row = 0; row < r; row++) {\r\n        const currRow = [];\r\n        for (let col = 0; col < c; col++) { //  previously I had it as 20*50\r\n            currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\n// initialising the node with its initial properties\r\nconst createNode = (row, col, startNode, finishNode) => {\r\n    let start_x = startNode[0];\r\n    let start_y = startNode[1];\r\n    let finish_x = finishNode[0];\r\n    let finish_y = finishNode[1];\r\n\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === start_x && col === start_y,\r\n        isFinish: row === finish_x && col === finish_y,\r\n        isWall: false,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        previousNode: null,\r\n        distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\r\n    }\r\n}\r\n\r\n// updating the grid, when the walls are tiggered\r\nconst gridWithWallToggled = (grid, row, col) => {\r\n    let newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    }\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\n\r\nconst gridDynamicNodes = (grid, row, col, pos) => {\r\n    console.log(`start node is currently at: row: ${row} col: ${col}`);\r\n    let newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (pos === \"start\") {\r\n        const newNode = {\r\n            ...node,\r\n            isStart: true\r\n        }\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    if (pos === \"finish\") {\r\n        const newNode = {\r\n            ...node,\r\n            isFinish: true\r\n        }\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    return newGrid;\r\n}\r\n\r\n// updating the grid, resetting the features except for the walls\r\nconst getGridWithoutPath = (grid) => {\r\n    let newGrid = grid.slice();\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            let newNode = {\r\n                ...node,\r\n                distance: Infinity,\r\n                isVisited: false,\r\n                previousNode: null,\r\n                distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n    let newGrid = grid.slice();\r\n    for (let wall of walls) {\r\n        let node = grid[wall[0]][wall[1]];\r\n        let newNode = {\r\n            ...node,\r\n            isWall: true,\r\n        };\r\n        newGrid[wall[0]][wall[1]] = newNode;\r\n    }\r\n    return newGrid;\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}