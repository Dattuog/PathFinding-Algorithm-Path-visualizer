{"ast":null,"code":"// Performs BFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  // queue to keep track of the visited nodes\n  let queue = [];\n  queue.push(startNode);\n  while (queue.length) {\n    const currNode = queue.shift();\n    // if the finsih node is reached then we return the visitedNodes array\n    if (currNode === finishNode) return visitedNodesInOrder;\n\n    // we skip the nodes which are walls, start node or finish node\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const {\n        row,\n        col\n      } = currNode;\n      updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n    }\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row, col, queue, grid, currNode) {\n  let next;\n  if (row > 0) {\n    next = grid[row - 1][col];\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n  if (row < grid.length - 1) {\n    next = grid[row + 1][col];\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n  if (col > 0) {\n    next = grid[row][col - 1];\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n  if (col < grid[0].length - 1) {\n    next = grid[row][col + 1];\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","queue","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode"],"sources":["C:/Users/Deekshith/Desktop/pathfinder/PathFinding-Algorithm-Path-visualizer/src/algorithms/bfs.js"],"sourcesContent":["// Performs BFS algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  // queue to keep track of the visited nodes\r\n  let queue = [];\r\n  queue.push(startNode);\r\n  while (queue.length) {\r\n    const currNode = queue.shift();\r\n    // if the finsih node is reached then we return the visitedNodes array\r\n    if (currNode === finishNode)\r\n      return visitedNodesInOrder;\r\n    \r\n    // we skip the nodes which are walls, start node or finish node\r\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\r\n      currNode.isVisited = true;\r\n      visitedNodesInOrder.push(currNode);\r\n      const { row, col } = currNode;\r\n      updateUnvisitedNeighbours(row, col, queue, grid,currNode);\r\n    }\r\n  }\r\n}\r\n\r\n// updates the neighbours,\r\n// in correspondance to the algorithm \r\nfunction updateUnvisitedNeighbours(row,col,queue,grid,currNode) {\r\n      let next;\r\n      if (row > 0) {\r\n        next = grid[row - 1][col];\r\n        if (!next.isVisited) {\r\n          queue.push(next);\r\n          next.previousNode = currNode;\r\n        }\r\n      }\r\n      if (row < grid.length - 1) {\r\n        next = grid[row + 1][col];\r\n        if (!next.isVisited) {\r\n          queue.push(next);\r\n          next.previousNode = currNode;\r\n        }\r\n      }\r\n      if (col > 0) {\r\n        next = grid[row][col - 1];\r\n        if (!next.isVisited) {\r\n          queue.push(next);\r\n          next.previousNode = currNode;\r\n        }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n        next = grid[row][col + 1];\r\n        if (!next.isVisited) {\r\n          queue.push(next);\r\n          next.previousNode = currNode;\r\n        }\r\n      }\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,GAAGA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC/C,MAAMC,mBAAmB,GAAG,EAAE;EAC9B;EACA,IAAIC,KAAK,GAAG,EAAE;EACdA,KAAK,CAACC,IAAI,CAACJ,SAAS,CAAC;EACrB,OAAOG,KAAK,CAACE,MAAM,EAAE;IACnB,MAAMC,QAAQ,GAAGH,KAAK,CAACI,KAAK,CAAC,CAAC;IAC9B;IACA,IAAID,QAAQ,KAAKL,UAAU,EACzB,OAAOC,mBAAmB;;IAE5B;IACA,IAAI,CAACI,QAAQ,CAACE,MAAM,KAAKF,QAAQ,CAACG,OAAO,IAAI,CAACH,QAAQ,CAACI,SAAS,CAAC,EAAE;MACjEJ,QAAQ,CAACI,SAAS,GAAG,IAAI;MACzBR,mBAAmB,CAACE,IAAI,CAACE,QAAQ,CAAC;MAClC,MAAM;QAAEK,GAAG;QAAEC;MAAI,CAAC,GAAGN,QAAQ;MAC7BO,yBAAyB,CAACF,GAAG,EAAEC,GAAG,EAAET,KAAK,EAAEJ,IAAI,EAACO,QAAQ,CAAC;IAC3D;EACF;AACF;;AAEA;AACA;AACA,SAASO,yBAAyBA,CAACF,GAAG,EAACC,GAAG,EAACT,KAAK,EAACJ,IAAI,EAACO,QAAQ,EAAE;EAC1D,IAAIQ,IAAI;EACR,IAAIH,GAAG,GAAG,CAAC,EAAE;IACXG,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC;IACzB,IAAI,CAACE,IAAI,CAACJ,SAAS,EAAE;MACnBP,KAAK,CAACC,IAAI,CAACU,IAAI,CAAC;MAChBA,IAAI,CAACC,YAAY,GAAGT,QAAQ;IAC9B;EACF;EACA,IAAIK,GAAG,GAAGZ,IAAI,CAACM,MAAM,GAAG,CAAC,EAAE;IACzBS,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC;IACzB,IAAI,CAACE,IAAI,CAACJ,SAAS,EAAE;MACnBP,KAAK,CAACC,IAAI,CAACU,IAAI,CAAC;MAChBA,IAAI,CAACC,YAAY,GAAGT,QAAQ;IAC9B;EACF;EACA,IAAIM,GAAG,GAAG,CAAC,EAAE;IACXE,IAAI,GAAGf,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC;IACzB,IAAI,CAACE,IAAI,CAACJ,SAAS,EAAE;MACnBP,KAAK,CAACC,IAAI,CAACU,IAAI,CAAC;MAChBA,IAAI,CAACC,YAAY,GAAGT,QAAQ;IAC9B;EACF;EACA,IAAIM,GAAG,GAAGb,IAAI,CAAC,CAAC,CAAC,CAACM,MAAM,GAAG,CAAC,EAAE;IAC5BS,IAAI,GAAGf,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC;IACzB,IAAI,CAACE,IAAI,CAACJ,SAAS,EAAE;MACnBP,KAAK,CAACC,IAAI,CAACU,IAAI,CAAC;MAChBA,IAAI,CAACC,YAAY,GAAGT,QAAQ;IAC9B;EACF;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}