{"ast":null,"code":"import { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\nexport function astar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (!closestNode.isWall) {\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      // if the finish node is reached then we return the visitedNodes array\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbours(closestNode, grid, finishNode); // Pass finishNode as a parameter\n    }\n  }\n}\n\n// updates the neighbors,\n// in correspondence to the algorithm \nfunction updateUnvisitedNeighbours(node, grid, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    // Calculate the Euclidean distance from neighbor to finishNode\n    const heuristicDistance = calculateEuclideanDistance(neighbor, finishNode);\n    neighbor.distance = node.distance + 1 + heuristicDistance;\n    neighbor.previousNode = node;\n  }\n}\n\n// Calculate the Euclidean (Pythagorean) distance between two nodes\nfunction calculateEuclideanDistance(nodeA, nodeB) {\n  const dx = nodeA.row - nodeB.row;\n  const dy = nodeA.col - nodeB.col;\n  return Math.sqrt(dx * dx + dy * dy);\n}","map":{"version":3,"names":["getAllNodes","sortNodesByDistance","getUnvisitedNeighbours","astar","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","length","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbors","neighbor","heuristicDistance","calculateEuclideanDistance","previousNode","nodeA","nodeB","dx","row","dy","col","Math","sqrt"],"sources":["C:/Users/Deekshith/Desktop/pathfinder/PathFinding-Algorithm-Path-visualizer/src/algorithms/astar.js"],"sourcesContent":["import { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\r\n\r\nexport function astar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (!closestNode.isWall) {\r\n      if (closestNode.distance === Infinity)\r\n        return visitedNodesInOrder;\r\n      \r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      // if the finish node is reached then we return the visitedNodes array\r\n      if (closestNode === finishNode)\r\n        return visitedNodesInOrder;\r\n      \r\n      updateUnvisitedNeighbours(closestNode, grid, finishNode); // Pass finishNode as a parameter\r\n    }\r\n  }\r\n}\r\n\r\n// updates the neighbors,\r\n// in correspondence to the algorithm \r\nfunction updateUnvisitedNeighbours(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Calculate the Euclidean distance from neighbor to finishNode\r\n    const heuristicDistance = calculateEuclideanDistance(neighbor, finishNode);\r\n    neighbor.distance = node.distance + 1 + heuristicDistance;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n// Calculate the Euclidean (Pythagorean) distance between two nodes\r\nfunction calculateEuclideanDistance(nodeA, nodeB) {\r\n  const dx = nodeA.row - nodeB.row;\r\n  const dy = nodeA.col - nodeB.col;\r\n  return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,mBAAmB,EAAEC,sBAAsB,QAAQ,SAAS;AAElF,OAAO,SAASC,KAAKA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EACjD,MAAMC,mBAAmB,GAAG,EAAE;EAC9BF,SAAS,CAACG,QAAQ,GAAG,CAAC;EACtB,MAAMC,cAAc,GAAGT,WAAW,CAACI,IAAI,CAAC;EACxC,OAAOK,cAAc,CAACC,MAAM,EAAE;IAC5BT,mBAAmB,CAACQ,cAAc,CAAC;IACnC,MAAME,WAAW,GAAGF,cAAc,CAACG,KAAK,CAAC,CAAC;IAC1C;IACA,IAAI,CAACD,WAAW,CAACE,MAAM,EAAE;MACvB,IAAIF,WAAW,CAACH,QAAQ,KAAKM,QAAQ,EACnC,OAAOP,mBAAmB;MAE5BI,WAAW,CAACI,SAAS,GAAG,IAAI;MAC5BR,mBAAmB,CAACS,IAAI,CAACL,WAAW,CAAC;MACrC;MACA,IAAIA,WAAW,KAAKL,UAAU,EAC5B,OAAOC,mBAAmB;MAE5BU,yBAAyB,CAACN,WAAW,EAAEP,IAAI,EAAEE,UAAU,CAAC,CAAC,CAAC;IAC5D;EACF;AACF;;AAEA;AACA;AACA,SAASW,yBAAyBA,CAACC,IAAI,EAAEd,IAAI,EAAEE,UAAU,EAAE;EACzD,MAAMa,kBAAkB,GAAGjB,sBAAsB,CAACgB,IAAI,EAAEd,IAAI,CAAC;EAC7D,KAAK,MAAMgB,QAAQ,IAAID,kBAAkB,EAAE;IACzC;IACA,MAAME,iBAAiB,GAAGC,0BAA0B,CAACF,QAAQ,EAAEd,UAAU,CAAC;IAC1Ec,QAAQ,CAACZ,QAAQ,GAAGU,IAAI,CAACV,QAAQ,GAAG,CAAC,GAAGa,iBAAiB;IACzDD,QAAQ,CAACG,YAAY,GAAGL,IAAI;EAC9B;AACF;;AAEA;AACA,SAASI,0BAA0BA,CAACE,KAAK,EAAEC,KAAK,EAAE;EAChD,MAAMC,EAAE,GAAGF,KAAK,CAACG,GAAG,GAAGF,KAAK,CAACE,GAAG;EAChC,MAAMC,EAAE,GAAGJ,KAAK,CAACK,GAAG,GAAGJ,KAAK,CAACI,GAAG;EAChC,OAAOC,IAAI,CAACC,IAAI,CAACL,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;AACrC"},"metadata":{},"sourceType":"module","externalDependencies":[]}